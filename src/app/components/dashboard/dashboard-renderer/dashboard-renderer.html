<div class="dashboard-container" *ngIf="dashboard"
     [class.compact-mode]="compactMode"
     [class.show-gridlines]="showGridlines"
     [class.edit-mode]="editMode">

    <!-- Dashboard Header -->
    <div class="dashboard-header" *ngIf="dashboard.name">
        <h1 class="dashboard-name">{{ dashboard.name }}</h1>
        <p class="dashboard-description" *ngIf="dashboard.description">{{ dashboard.description }}</p>
    </div>

    <!-- ============================================================
         Recursive row template â€” used for both top-level and nested rows.
         Single component instance, single selection state.
         ============================================================ -->
    <ng-template #rowContent let-rows="rows" let-availableWidth="availableWidth">
        <div *ngFor="let row of rows; trackBy: trackRow"
             [class]="getRowClasses(row)"
             [ngStyle]="getRowStyle(row)"
             [style.grid-template-columns]="getGridTemplate(row)">

            <!-- === EDIT MODE === -->
            <ng-container *ngIf="editMode">
                <ng-container *ngFor="let cell of getRowCellMap(row); trackBy: trackCell">

                    <!-- Occupied cell -->
                    <div *ngIf="cell.type === 'item' && cell.item && isItemVisible(cell.item)"
                         [class]="getItemClasses(cell.item)"
                         [style.grid-column]="cell.startSegment + ' / span ' + cell.spanSegments"
                         class="edit-mode-item">

                        <button class="item-remove-btn"
                                (click)="onRemoveItem(row, cell.item!.index, $event)"
                                title="Remove item">
                            <mat-icon>close</mat-icon>
                        </button>

                        <div class="item-header" *ngIf="cell.item.title && cell.item.type !== 'text'">
                            <span class="item-title">{{ cell.item.title }}</span>
                        </div>

                        <div class="item-content" [class.has-header]="cell.item.title && cell.item.type !== 'text'">
                            <ng-container [ngSwitch]="cell.item.type">
                                <ng-container *ngSwitchCase="'component'">
                                    <ng-container *ngIf="getComponent(cell.item) as component">
                                        <ng-container *ngComponentOutlet="component; inputs: getComponentInputs(cell.item)"></ng-container>
                                    </ng-container>
                                    <div *ngIf="!getComponent(cell.item)" class="component-error">Component not found</div>
                                </ng-container>
                                <ng-container *ngSwitchCase="'metric'">
                                    <dashboard-metric-card [data]="getMetricData(cell.item)"></dashboard-metric-card>
                                </ng-container>
                                <ng-container *ngSwitchCase="'text'">
                                    <div [class]="'text-content ' + (cell.item.cssClass || '')">{{ getTextContent(cell.item) }}</div>
                                </ng-container>
                                <ng-container *ngSwitchCase="'table'">
                                    <div class="table-placeholder">Table content</div>
                                </ng-container>
                                <ng-container *ngSwitchCase="'graph'">
                                    <div class="graph-placeholder">Graph content</div>
                                </ng-container>
                                <!-- Container with nested rows (recursive) -->
                                <ng-container *ngSwitchCase="'container'">
                                    <div class="nested-row-container" *ngIf="cell.item.nestedRows?.length">
                                        <ng-container *ngTemplateOutlet="rowContent; context: {
                                            rows: cell.item.nestedRows,
                                            availableWidth: calculateNestedWidth(availableWidth, cell.spanSegments, row.rowSegments)
                                        }"></ng-container>
                                    </div>
                                    <div class="nested-container" *ngIf="!cell.item.nestedRows?.length && cell.item.items?.length">
                                        <ng-container *ngFor="let nestedItem of cell.item.items; trackBy: trackItem">
                                            <div class="nested-item" [style.width]="(nestedItem.rowSegmentsUsed / 12 * 100) + '%'">
                                                <ng-container [ngSwitch]="nestedItem.type">
                                                    <dashboard-metric-card *ngSwitchCase="'metric'" [data]="getMetricData(nestedItem)"></dashboard-metric-card>
                                                    <div *ngSwitchCase="'text'" class="text-content">{{ getTextContent(nestedItem) }}</div>
                                                </ng-container>
                                            </div>
                                        </ng-container>
                                    </div>
                                </ng-container>
                                <ng-container *ngSwitchDefault>
                                    <div class="unknown-type">Unknown: {{ cell.item.type }}</div>
                                </ng-container>
                            </ng-container>
                        </div>
                    </div>

                    <!-- Empty cell placeholder (1 segment, individually selectable) -->
                    <div *ngIf="cell.type === 'empty'"
                         class="empty-cell-placeholder"
                         [class.selected]="isCellSelected(row, cell.startSegment)"
                         [class.selection-start]="isSelectionStart(row, cell.startSegment)"
                         [class.selection-end]="isSelectionEnd(row, cell.startSegment)"
                         [class.selection-single]="isCellSelected(row, cell.startSegment) && isSingleCellSelection()"
                         [style.grid-column]="cell.startSegment + ' / span 1'"
                         (click)="selectCell(row, cell.startSegment, availableWidth)">
                        <mat-icon class="empty-cell-icon">add</mat-icon>
                    </div>

                </ng-container>
            </ng-container>

            <!-- === NORMAL MODE === -->
            <ng-container *ngIf="!editMode">
                <ng-container *ngFor="let item of row.dashboardItems; trackBy: trackItem">
                    <div *ngIf="isItemVisible(item)"
                         [class]="getItemClasses(item)"
                         [style.grid-column]="getItemGridColumn(item)">

                        <div class="item-header" *ngIf="item.title && item.type !== 'text'">
                            <span class="item-title">{{ item.title }}</span>
                        </div>

                        <div class="item-content" [class.has-header]="item.title && item.type !== 'text'">
                            <ng-container [ngSwitch]="item.type">
                                <ng-container *ngSwitchCase="'component'">
                                    <ng-container *ngIf="getComponent(item) as component">
                                        <ng-container *ngComponentOutlet="component; inputs: getComponentInputs(item)"></ng-container>
                                    </ng-container>
                                    <div *ngIf="!getComponent(item)" class="component-error">Component not found in registry</div>
                                </ng-container>
                                <ng-container *ngSwitchCase="'metric'">
                                    <dashboard-metric-card [data]="getMetricData(item)"></dashboard-metric-card>
                                </ng-container>
                                <ng-container *ngSwitchCase="'text'">
                                    <div [class]="'text-content ' + (item.cssClass || '')">{{ getTextContent(item) }}</div>
                                </ng-container>
                                <ng-container *ngSwitchCase="'table'">
                                    <div class="table-placeholder">Table content (use 'component' type with templateClassTable)</div>
                                </ng-container>
                                <ng-container *ngSwitchCase="'graph'">
                                    <div class="graph-placeholder">Graph content (integration pending)</div>
                                </ng-container>
                                <!-- Container with nested rows (recursive) -->
                                <ng-container *ngSwitchCase="'container'">
                                    <div class="nested-row-container" *ngIf="item.nestedRows?.length">
                                        <ng-container *ngTemplateOutlet="rowContent; context: {
                                            rows: item.nestedRows,
                                            availableWidth: calculateNestedWidth(availableWidth, item.rowSegmentsUsed, row.rowSegments)
                                        }"></ng-container>
                                    </div>
                                    <div class="nested-container" *ngIf="!item.nestedRows?.length && item.items?.length">
                                        <ng-container *ngFor="let nestedItem of item.items; trackBy: trackItem">
                                            <div class="nested-item" [style.width]="(nestedItem.rowSegmentsUsed / 12 * 100) + '%'">
                                                <ng-container [ngSwitch]="nestedItem.type">
                                                    <dashboard-metric-card *ngSwitchCase="'metric'" [data]="getMetricData(nestedItem)"></dashboard-metric-card>
                                                    <div *ngSwitchCase="'text'" class="text-content">{{ getTextContent(nestedItem) }}</div>
                                                </ng-container>
                                            </div>
                                        </ng-container>
                                    </div>
                                </ng-container>
                                <ng-container *ngSwitchDefault>
                                    <div class="unknown-type">Unknown item type: {{ item.type }}</div>
                                </ng-container>
                            </ng-container>
                        </div>
                    </div>
                </ng-container>
            </ng-container>
        </div>
    </ng-template>

    <!-- Render top-level rows using the recursive template -->
    <ng-container *ngTemplateOutlet="rowContent; context: {rows: dashboard.rows, availableWidth: containerWidth}"></ng-container>

    <!-- Empty State -->
    <div class="empty-dashboard" *ngIf="dashboard.rows.length === 0">
        <mat-icon>dashboard</mat-icon>
        <p>This dashboard is empty</p>
    </div>
</div>

<!-- No Dashboard State -->
<div class="no-dashboard" *ngIf="!dashboard">
    <mat-icon>warning</mat-icon>
    <p>No dashboard data available</p>
</div>
